 



https://data101.dtek.se/


#..................................Cryptogrphy...............................
	* attack: is an intentional activity conducted or initiated by a human, attempting to cause a breach in a 
	system or to compromise a system
	
	* breach: is the resulting violation of the security policy of a system
	
	* intrusionor penetration) the term used to denote an attack and its corresponding breach.


	* a vulnerability is a place in the system where it is open for attack (at least to some extent)

	* a threat is something that can give undesired, negative consequences for the system
	
	* a countermeasure or protection or control is a technique that will protect the system against attacks



	* transposition: by changing the message's alphabets position 
	* substitution: by changing all lphabets inthe message by other symbols or alphabets
	
	
	 * one time pad approach: 
	 	- K: random string used as a key and it inly used only once.
	 	- pi: (message): The Key has the same size as the message 
	 
	 
	 * traditional symmetric model with secret key: Sender sends a crypted messsage that is encrypted by a 
	 key. the receiver decrypt it by the same key that sender has used for encryption of the message. 
	 NOTE: using this approach if the channel between sender and receiver is not secure then the cryptanalysis 
	 can also read the key and even modify it therefor the channel should be confidential and authenticated. 
	
		* note that only the key should be secret. 
		
		diffrent ways that attcaker can break the message: 
		1) cipher-only: the cryptanalysis only has encrypted text. this is the most difficult way.
		
		2) known-plaintext: the cryptanalysis has some pplaintext-ciphertext pairs.  
		
		3) Chosen-plaintext/chosen-ciphertext: the cryptoanalysis can make tests with selected plaintext 
		and get the corresponding encryption. the easiest way for cryptanalysis.  
		
		Diffusion(spridning) and Conffision(förvirring): are two critical concepts in cryptograpgy:
		- Diffusion: changing one symbol in plain text affects many symbols in the ciphertext. And 
		changing one symbol in the key affects many symbols in the ciphertext. 
		
		- Conffusion: The cipher text must depend on the plaintext and the key in a complicated way so 
		that the derivation of statical relation is hard to do. 
		
	
	* Asymmetrical Systems: public-key-systems:
	Each person has two keys. In priciple encryption is done by private key and decryption by public key. 
	but this will not achive the confidentiality and therefor singing/signatures are used. 
	by signature the document being encrypted and signed by the private key and when decryption the public key 
	is used to check if it matches the signature. 
	In many cases first the hash will be calculated and this hash will be signed then the hash and the 
	original document will be sent. 
	
		* Diffie-Hellman system: 
			One-way function: f(x) a^x (modulo p) // 
			both sender and receiver agrees on b, 
			sender chooses x1 and receiver chooses x2
			sender calculates y1 = b^x1 and receiver calculates y2 = b^x2
			
			sender sends y1 to receiver and receiver sends y2 to sender // the atacker can listen!!!
			
			sender calculates y2^x1 = b^x1 x2
			receiver calculates y1^x2 = b^x1 x2
		
			NOTE: this method is riskable of man in the middle attack!!!
		
		* RSA: most used.
		
		* PGP-GnuPG: application for encryption and signing of emails. It uses RSA and IDEA
		
		
	*
	
#................................ LAB 1.............................
	
	* public key cryptography is asymmetric which means it uses 
	two separate keys while symmetric encryption uses only one 
	key.
	
	public key encryption is more secure from cryptanalysis that 
	symmetric encryption. 
	
	- The security of any encryption scheme depends on:
	1) the length of key 
	2) the computational work involved in breaking a cipher. 
	
	* A public-key encryption scheme has six ingredients: 
	1) Plaintext: readable message or data that is fed into algorithm as input 
	2) Encryption algorithm: various transformations on the plaintext
	3,4) public and private key: one is used for encryption and the other is used for decryption 
	5) Cipher text: scrambled message produced as out put. It depends on the plaintext and the key. For a 
	given 
	message and two different keys will produce two different ciphertexts. 
	
	6) Decryption algorithm
	
	* Encryption with public key: 
		- sender: 
			i) sender puts the plaintext (X) into encryption algorithm, 
			ii) the algorithm adds the recivier's public key (Pu)
			iii) cipher text being transmited as Y = E(Pu X)
	
		- receiver: received ciphertext is fed into decryption algorithm with receiver's private key(Pr)
		the plain text is now as X = D(Pr Y)
	
	* Encryption with private key:
		- sender: 
			i) sender puts the plaintext (X) into encryption algorithm, 
			ii) the algorithm adds the sender's private key (Pr) 
			iii) cipher text being transmited as Y = E(Pr X)
			
		- receiver: received ciphertext is fed into decryption algorithm with receiver's public key(Pu)
		the plain text is now as X = D(Pu Y)
		
	
	essential steps are the following: 
	1. Each user generates a pair of keys to be used for the encryption and decryption of messages. 
	
	2. Each user places one of the two keys in a public register or other accessible file. This is the public 
	key. The companion key is kept private. As Figure 2.7a suggests, each user maintains a collection of 
	public keys obtained from others. 
	
	3. If Bob wishes to send a private message to Alice, Bob encrypts the message using Alice’s public key.
	
	4. When Alice receives the message, she decrypts it using her private key. No other recipient can decrypt 
	the message because only Alice knows Alice’s private key.
	
	
	* Man in the middle attack (MITM): 
	
	* Digital signature: 
	Fro creating a digital signature, a secure hash function such as SHA-512 generate a hash value for the 
	message then the hash code will be eencrypted with private key. 
	
		* Sender sends the signed message, the receiver receives a a message plus a signature. 
		The receiver will:
			1) calculate a hash value for the message 
			2) decrypts the signature using the sender's public key
			3) compares the calculated hsh value to the decrypted hash value 
			
			if the calculated hash value and decrypted hash value matchs, the sender knows that 
			the message was signeed by the specific sender. 
		Note that it's note safe yet and there is no protection of confidentiality because everyone can
		decrypt the message by using the senders's public key. using this approch we can just garantee
		that who is the owner of the message that have signed the message with its private key. 
		
	* Public-key certificates:
	To solve the confidentiality problem with signing we can use public-key certificates.  A certificate 
	consists of a public key plus a user ID of the key owner, with the whole block signed by a trusted third 
	party. 
	
		The certificate also includes some information about the third party plus an indication of the 
		period of validity of the certificcate. 
		
		Typically the third party is a certificate authority (CA) e.g. a goverment agency. 
		
		A user can present his/her public key to CA in a secure manner and obtain a signed certificate. 
		The user can then publich the certificate. Anyone needing this user's public key can obtain 
		the certificate and verify that it is valid.   
	
	
		This approach is as follows:
		sender: 
		1) unsigned certificate contains user IDand user's public key. 
		2) Generate a hash code for the unsigned certificate 
		3) Encrypt hash code with CA's private keyto form the signature. 
		4) now we a have a signed cetificate. 
		
		receiver: 
		1) decrypt signature with CA's public key to recover hash code. 
		2) Recipient can verify signature by computing hash code values. 
		
		
	* Public-key encryption can be used to protect the a symmetric key in general in two ways:
	
		1) using Deffie-Hellman key exchange: there is various of approaches to do this safily.
		
		2) Digital Envelopes: 
			sender:
			2.1) Generate a random symmetric key that will be used only once. 
			2.2) Encrypt the message using symmetric encryption the one-time-key. 
			2.3) Encrypt the one-time-key using public key encryption with the recipient's public key.
			2.4) attach the encrypted one-time-key to the encrypted message
			
			recipient: after receiving the digital envelope: 
			2.1) Decrypt the symmetric mkey using recipient's private key
			2.2) decrypt the message using the random symmetric key
			 
			 
			
	
........................................jadi tutorial.................................


	The sender can use public key of reciver and encrypt the message with that key. 
	
	* ssh uses asymmetric encryption as well. 
	
	* to start ssh service: 
	$ sudo service ssh start
	
		first time trying ssh a server the system asks about the adreement on the connection then after 
		writing yes the system adds host as the known hosts. 
		
		- to create a ssh key: 
		$ ssh-keygen < -t the format of key by default empty means rsa>
		
			it will ask about some parameters like oassphrase which means if you want to enter the 
			password each time using the key. 
			
			after geerating the key a fingerprint will also be shown as somthing like SHA256....
		
		- for running only one command on the target machine use: ex:
		$ ssh <ip address> ls // do the ls operation and exits from the target after that
		
		- Every thing about ssh being stored in .ssh directory. contents are as follows:
			
			+ known_hosts: list of known hosts for the system. 
			To remove the a hosts as a known host fro system:
			$ ssh-keygen -R <ip_addres_of_that_host>
			
			+ id_rsa: the private key
			
			+ id_rsa.pub: the public key
			
			+ authorized_keys: list of authorized keys if you add your public key in this file when 
			ssh a host the password not be asked again. 
			NOTE: this way is not recommended instead use: 
			$ ssh-copy-id <ip address of the host> // this will do the same as above. 
		
			
			
		- To ssh to a server: $ ssh <ip address>
		other arguments:
			
			$ ssh -v <ip address> // to see all ssh do while connecting a host
			
		- configuration file for ssh: /etc/ssh/sshd_config
		
		- ssh-agent:
			uses as: $ ssh-agent /bin/bash
				 $ ssh-add
			
			this will add all key to the agent, and the agent keeps all key in the memory then first 
			time sshing it asks about password but after that it does not beceuase it has the password 
			stored.
			
			Other usage of agnet is when having diffrent servers and there is a jump server. by using 
			normal way of public key it would not work because the private key is only on the lokal 
			machine and jump host cant make connectio to the target host. but using agent it will work 
			because the agent will transform the keys on the lokal machine to jump server and jump 
			server can make connection with the target server. 
			
		

	- ssh tunnels: 
	1) Loka tunnel: 
	$ ssh -L <entry port on local machine xp>:<target machine to be connected Y>:<exit port of target yp> <ip of machine that will be used as tunnel> 
			
			-L indicates a lokal tunnel
			
			local host on port xp can see the target machine Y that runs on port yp
			
			if we have a jump server then we can use localport and target ip address and port of 
			target server and the jump server ip address in ordering. 
			
	2) Remote/reverse tunnel: 
	$ ssh -R <port for geust yp>:<adddress of local address X>:<local port xp> <address of machine that can see my local Y>
	-R indicates remote
	then the machine Y can see my local machine X that runs on port xp on its yp port
	
	
	3) Dynnamic port forwarding: 
	Socks proxy:
	$ ssh -D <port of local machine> <ip of the target server> 
	
	
	
	Note: X11 is responsible for graphic in linux. 
	
	* ssh with graphic: to ssh and see the graphic of the target graphic use: 
	$ ssh -X  <ip address>

	
	
	
	* PGP (Pretty Good Privecy)-GPG: encrypting data: GPG is for the GNU:
			
		- usage: 
		+ generate/create keys
		+ encrypt data
		+ signing 
		
		if just gpg being entered then sysyem asks about message to be encrypted:
		$ gpg
		
		- To list all keys:
		$ gpg --list-keys
		
		- To generate a key: 
		alt1)
		$ gpg --full-generate-key
		
		alt2)
		$ gpg --gen-key
			
			+ it asks a name for owner, it should be atleast 5 charachters.
			+ Email address <email@server.domain>
			+ passphrase: a password for the key
		
		- To share the public key 
			alt1) in binary format: 
			$ gpg --export <key owner name> > <filenameToStoreTheKey.pub.key>
		
			alt2) in ascii format: 
			$ gpg --export -a <key owner name> > <filenameToStoreTheKey.pub.key>
			
		
			
		- To encrypt data to send to receiver we have to first import the receiver's public key into gpg tool set. 
		to do this import:
		$ gpg --import <fileThatContainTheReceiver'sPublicKey>
		
		- To encrypt the file/message:
			alt1) to binary format encryption 
			$ gpg --out <EncryptedFileNameAsOutput> --recipient <receiver'name> --encrypt <fileNameToBeEncrypted>
		
			alt2) 
			$ gpg --out <EncryptedFileNameAsOutput> -a --recipient <receiver'name> --encrypt <fileNameToBeEncrypted>
		
		
		 
		- To decrypt the encrypted file: 
		$ gpg --out <fileNameToStoreDecryptedFile> --decrypt <encryptedFile> 
		it can ask passphrase which was used for user when creating the key.
		
		
		- Signing: 
		since the data is encrypted by private key then the data should only be decrypted by public key therefor signing is important otherwise the 
		message can be opnned or modified by others. 
			
			+ To sign:
			alt1) bianry 
			$ gpg --output <theFileNameToStoreSignedMessage> --sign <FileNameToSign>
			
			alt2) Ascii 
			$ gpg --output <theFileNameToStoreSignedMessage> -a --sign <FileNameToSign>
			
			alt2) to keep message separate from signature:
			$ gpg --output <theFileNameToStoreSignedMessage> --clearsign <FileNameToSign>
			
			+ To check the signature:
			$ gpg --verify <signedFile>
			
			NOTE: in git we can sign with: $ git -S
			
			+ To oppen the signed file in unsigned format:
			$ gpg --output <fileTostore> --verify <signedFile>


			+ To revoke the key: 
			$ gpg --output <theKeyFile> --gen-revoke ownerName ownerMail
			
			
			+ gpg-agent: like ssh-agent thats keeps keys and password in memory.
			
			
			
			
#...............................GNU privacy handbook...............................................

	* Generate a new keypari: 
	$gpg --gen-key
	
	* Generating a revocation certificate
	gpg --output revoke.asc --gen-revoke mykey
	
	* to encrypt and sign:
	$ gpg --output ... --encrypt ... --sign ... --recipient ... filename 
	
	*to view and edit: 
	$ gpg --edit-key <mail/userID>
	
		COMMAND> 
		toggle: switches between public and private components of key 
		
		check: the signature of the given user can be checked by this command
		
		adduid/deluid: to add/delete userID
		
		addkey/delkey: to add/delete a sub key
		
		revkey: to revoke key
		
		revsig: to revoke signature
		
		trust: user to verify other keys on your public keyring
		
		help: for info about all commands and descriptions
		
		
	
	* to validate the imported key:
	$ gpg --edit-key <email/userId of the imported key>
		
		1)
		command> fpr 
		will show the fingerprint of the owner
		
		2)
		command> sign
		to sign the key
		
		
	* Distributing keys: 
	to distibute public key saflly public key servers are used to collect and distribute public keys. 
	A received public key in server is either added to the server's database or merged with existing key if 
	already present.
	
		+ when a request comes to the server, the server consults its database and returns the requested 
		public key if found.
		
		+ When a sender signs the recipient's key then the sender sends the signed key to the server. 
		the key server adds sender's signature to its copy of recipient's key. 
		
		
		+ To send one or more key to a server: --send-key
		+ The key server to which send the keys is specified by: --keyserver
		
		+ general form:
		$ gpg -keyserver <serverName.pgp.com> --recv-key/--send-key <0xspecifiedKey>
	
	
	
#.................................Covert channel........................

	* A covert channel (hemlig kanal) is a channel that leaks information from protected area it can be modul/ 
	program to an unprotected area. It is also known as lekage path.
	
		+ A most importance characterization of covert channel is bandwidth wich counts in bits/second
		
		+ covert channel can make use of almost any means for the information transfer. 
		(sv: hemlig kanal kan använda nästan alla medel för informationsöverföring)
		
		+ A typical environment is a highly sentensive system. 
		
		# There are two types of covert channel:  storage and timing channels;
			+ storage channels: for example if one process writes to an object and process2 reads it
			The Spy' program (mallicius program) can get informations about:
				- object attributes: lenght, format, date, ...
				- object existence
				- shared resourses
			
			+ Timing channels: for example process1 creates some "effect" and process2 measure time
			
			
	* Hiding Basic: 
	
	# steganography ("hidden writing"): means hidden writing as does cryptography but the idea this approach 
	is that hide even the existence of the message that is secret. This approach embeds a secret message in 
	some carrier, such as an open message
	
		some methods is:
		-hiding text in a picture
		-hiding picture in other picture ....
		
	#  Watermarking: means embedding a message into a cover message, normally to discourage theft of the 
	intellectual property rights. 
	(sv: innebär att bädda in ett meddelande i ett omslagsmeddelande, normalt för att motverka stöld av 
	immateriella rättigheter.)
	
		example: media watermarking: 
		- cover: digital image
		- secret: copyright notice
		
		
		
	
	* Data remanence & Side-channel Attcks: 
	
	# Data remanence: is "residual iinformation remaining on storage media after clearing" or 
	"the ability of computer memory to retain previously stored information beyond its intended lifetime".
	
		+ Floppy disks/magstripe cards: write heads are not perfectly aligned on different systems, with
		specialized tools one can recover data. 
		
		+ Hysteresis property of ferromagnetic media: weak form of data can remain even when owerwritten. 
		
		+ CMOS-flip-flop curcuits: Data can be retained for minutes at low temprature. 
		
		+ File/OS/Database system: When a file being deleted it is only marked as deleted even though
		all information is still there. 
		
	# side-channel attack: is any attack based on information gained from physical implementation of an 
	embedded system, for example a cryptosystem. based on information that can be gained from the device. 
	
		+ It normally requires physical access to the hardware. 
		
		+ Different types of side channel attacks: 
		- timing attack: attack based on measuring how much time varios computation take to perform.
		- power monitoring attack: attack based on observing the varying power consumption by the hardware 
		during compution. 
		
		- Electromagnetic attacks: based on observing electromagnetic emanation, cp. sv: Röjande 
		strålning.
		
		- Acoustic cryptanalysis: attackcs which exploitthe sound produce durring a compution. 
		- Differential fault analysis: in which secrets are discovered by introducing faults in 
		computation. 
		
		
#......................................Lab1 outcomes..............................

för att skicka och ta emot crypterade meddelande:
	1) lägg till mottagares pub key och signera det. 
	2) mottagaren ska göra samma sak.
	3) skicka tillbaks mottagares crypterade och signerade pub key och ta emot din encrypterade och signerade pub key. 
	4) både sidor nu lägger till sina mottgade pub key 
		
	


#.................................Building an authentication system............................................
	
	Passwords: 
		man ska ha restriktioner att hur password ska va t.ex. minst 8 karakter minst en av de sifrra , 	
		minst en av de Stor bokstav och minst en små bokstav. 
		
		* i linux finns det /etc/passwd-filen används för att lagra grundläggande information om användare 
		på ett Linux-system. När en användare loggar in eller när systemet behöver information om en 
		specifik användare, tittar det på denna fil för att hämta relevant information. Här är några sätt 
		på vilka /etc/passwd används: 
			
			+ Authentication vid inlogning. 
			+ användarsinformation: saker som hemkatalog, ...
			+ rättigheter och behörigheter
			+ processer och filer: när en användare startar en process, används användarens UID
			och GID för att koppla den processen till rätt ägare. 
			
			+ System adminstration: Adminstratörer kan använda denna fil för att visa och hantera 
			användarkonto, tilldela eller ändra lösenord och liknande uppgifter. 
	
			
			# för varje user finns det:
			username:password:UID:GID:GECOS:home_directory:shell
			
			- username: används när user logger in mellan 1 till 32 längd. 
			- password: en x character indikiterar att encrypterade password är sparad i /etc/shadow 
			file
			
			-user ID (UID): uid 0 är reserverad för root, uid:er 1-99 är reseverad för andra 
			fördefinierade konto. uid:er 100-99 är reserverade av system för administritiva och system
			/accounts group. 
			
			- group ID (GIU): den primiära group id är sparad i /etc/group file. 
			
			- GECOS: General Electric Comprehensive Operating System, denna ält används för att
			lagra informationer såsom fullständigt namn, tel, kortnummer, ..
			de separeras med ","
			
			- home directory: den absoluta path till directory:n user kommer hamna efter inlogningen. 
			om detta directory inte finns då user directory visas som "/"
			
			- Command/shell: den absoluta path of en command eller shell (/bin/shell) typpically it is 
			a shel but not neccesary. 
			
			
			
		Storting passwords:
		
		1) in clear text som shadow filen i linux
		
		2) encrypt the password:
					
			+ Man ska inte använda seret algoritm detta leder till säkerhet genom osäkerhet.
			+ istället man ska använda en bra och open algoritm och hålla något mindre hemligt.   
			
			
			problem: 
			- Man kan inte använda en normal encryption algoritm, t.ex det är ingen bra ide att 
			encryptera med key sparad på disk eftersom om key bli stulen då password är det också
			kallas för chicken and ägg problem. 
			
			# One-way function: detta sätt är användbar för encryptering av password. det funkar som 
			hash men man kan räkna bara på en väg och kan aldrig gå tillbaka. så man kan aldrig få 
			orginallet. 
			
				## defaul är det MD5-crypt, bycrypt, sha256-crypt, sha512-crypt och 
				den traditionella/historiska DES (DES tillåter bara 8-byte passwords). 
				nya alternative: Argon2 (senare pratas om)
				
				OBS: MD5 är svagt så är inte rekommenderat. 
				
				* i one-way function man sparar hashet av lösenord istället själva lösenord i
				 plain text. När user loggar in i system då funktionen tar det input som skrivs av 
				 user, detta input blir hashat på samma sätt som man har hashat det orginala 
				 password när user skapade det, sen man jämför hashet om det är samma värde då 
				 user kan logga in. 
				 
				 * problems with one-way fuunction: 
				 - om man har lösenorden sparade i en fil för t.ex. för olika user då user kan se 
				 hashet av andra user och om två user har samma lösenord kommer de ha samma hash
				 
				 - detta sätt är svag för dictionary då man kan prova hashet med sictionary och 
				 gissa till sig till passwordet. 
				 Detta sätt av attck kan göras med en RAINBOW table. 
				 
				
				* To solve the problem with one-way function: Adding salt
				
				
				* To make offline dictionary attack harder: 
					+ make the check as slow as possible: we want to make the actual hashing 
					as slow as possible. for real users, they will only wait once for this 
					hash to take place, for attacker many times. 
					
					+ adding some sanity check on password. if user enters weak password do 
					not accept it until user enters better password. 
				 
				 	

	
	UNIX Security: Security in linux is focused most in three area: 
	1) Memory protection for processes: Processes have own virtual address space, and communication
	with hardware is done through the operating system .
	
	2) File are protected between users. "everything is a file" concepr implies that same mechanisms apply for 
	all bjects. 
	
	3) Maintenance is carried out by a "realiable" system adminstrator, also known as root or super user. 
	
	to switch user:
	$ su // then enter username and password 
	
	
	
	* File protection
	to se the files protection information: 
	$ ls -l 
	rw-r--r- numberOfFileName owner group fileSize modificationDate nameOfFile
	
		# classes and permissions: 
		9 characters grouped in 3 classes and 3 kinds of permissions: 
		
		classes: 
			- owner
			- Group
			- other
		
		persmitions: 
		 	- r = class has read acces to file
		 	- w = class has write access to file
		 	- x = class has execute access to file
		 
		 ex: -rwx r-- --- user group file.txt
		 user has rwx access 
		 group can only read the file
		 others have no access 
		 
		 * change the acess for file: using chmod command 
		 this command has two different modes either usin:
		 
		 1) octal file permissions: four octal number is used to set permissions:
		 	
		 	0744
		 	0: SUID/SGID
		 	7: 111: rwx: owner
		 	4: 100: group
		 	4: 100: other
		 	
		 2) textural manner: using '+', '=' and '-' for addin r,w,x e.g. +x
		 	
		 	gerneral: class+ or- or '=' permission
		 	- to write perissions for group: g+w
		 	- to remove read permission for other: o-r
		 	- to set read access for user: u=r
		 	
		 
		* SUID program: setting temporary permissions
		SUID program is a program for wich the"s" bit is set. The s bit indicates that operating system 
		lets user to perform the desired operation with the priviliges of the owner of the object. When
		execution finished, user assume ordinary priviliges. 
		
			to see which programs are SUID on the system:
			$ find / -perm -4000 -print
			
			* Changing the s flag: there are two main methods:
			 1) chmod 4755 file.txt
			 2) chmod u+s file.txt
			 
			 then running ls -la givew for example rws-r-x r-x
			 
		* setuid() function call can also be used in  c kod to change the user id and give more 
		permissions.

		* The current euid is 0 before e.g. calling setuid(20757),
                which means that the process has root privileges and can run the program with any user ID.
		However, after calling setuid(20757), the process permanently drops its root privileges and sets its euid, 
		ruid, and saved set-user-ID to 20757. This means that the process can no longer run the program with root privileges, 
		unless the program itself has the setuid bit set and is owned by root. In other words, setuid(20757) does not prevent the process from running the program,
		but it does prevent the process from running the program with root privileges
		
		The setuid bit is indicated by an s in the file mode, as in -rwsr-xr-x. This means that when a user executes the file, the process will run with the euid of the file owner, regardless of the user’s own identity
		
	
	* Authontorization, Access control and mobile malware: 
	
		* Authontication: is a process to verifying a user's identity. 
		* Message authontication is another conceps that is not eqvivalent to authentication. 
		Message authontication is about chaeck of message authenticity (sv: äkthet) and source. 
		
		* In OS each user has one identifier that is username and one authenticator which is password. 
		
		* basic of access control and user accountability  has two step:
		1) identification: specify identifier
		2) verification: bind entuty and identifier. 
		
		
		* Authentication procesure: consists of 4 stages: 
		1) identification of the user 
		2) provision of some kind of authentication information which sould be secret 
		3) transmission of the authentication information to the system through a secret channel. 
		4) validation of the authentication information with respect to some reference information 
		Note: error and attacks can occur in all 4 sages!
		
		* Authentication information can be of 3 different generic types: 
			- something user know like password, pin code, ..
			- something user have like smartcard
			- something user afre (do) like fingerprint 

		* Transmission channel: is often the weakest link specially when long distance are involved.
		The usual transmission threats and problems apply such as: 
			-  eavesdropping 
			- manipulation of routers, gateway. 
			- replay attacks
			
		* Validation of authentication: the system must have some reference information in order to
		validate the authenticaition information. 
		
		 	- An attack can be launched againsst the reference info e.g. read stored password, change 
		 	the reference info. 
		
			- Protection of password reference :
			a) store in a file with strong and limited access control
			b) encryption
			c) (a+b)
			
		
		* Access control: is the prevention of unautheorized use of a resource. the resource can be:
			- process
			- object 
			- access right e.g. write, execute, read, delete, create, search ,...
			
			* access control provided using an access control matrix:
			list of subject in one dimension (rows)
			Each entry specifies access right of the subject to that object
			
				- access control matrix is often sparse.  
				
		* Mobile malware: the y usually infect the system to stole informations. 
			
		
		
		
#..................................Security in Operating system......................................

	security concept in os includes> 
		1) authentication, autorization, access control: protecting files and memory by reference model
		2) Separation: Virtual memory, virtual machines
		3) operating system kernel: TCB (Trusted computing base), secure boot, software, hardware
		4) Hardware support: (TPM, Intel SGX, ARM TrustZone), (Address space layout randomization, 
		execution prevention, No-execute-bit(NX))
		
		
		Layer of a computer system: 
		--------------------
		|   Applications   |
		--------------------
		|     Services     |
		--------------------
		| Operating System |
		--------------------
		|    OS kernel     |
		--------------------
		|    Hardware      |
		--------------------
		
	
	* Separation: The most basis and important part of OS protection is separation 
	Types of separation: 
		- physical separation: physical objects such as CPU's, printers, etc. 
		- Temporal: execution at different time, one process has control of the machine but only durring 
		a certain time interval.
		
		- Logical separation: domains, each iser gets the impression that he is alone in the system .
		- Cryptographic: hiding data, so that other users cannot understand them. 
		
	* Protected objects: in os there are many protect objects, in principle all objects in the os need 
	protection, but in particular those that are sharable need absolutly protect such as: 
		- files, memory, programs, procedures, data, IO devices
		- Hardware such as: operating system mechanisms, bus control, interrupt control, status register. 
		
		
	* Kernel protection: the kernel is the part of os that performs the lowest level functions. It has a part 
	that is called security kernel which is responsible for the security mechanism of the entire os. 
		
		* Reference monitor (RM): is a part of the security kernel and some sort of policy that controls 
		access to objects. T
		he goal is:
			- complete mediation: the reference monitor needs this and it means that the roles must be 
			enforced on every access. 
			
			- The reference monitor needs to be isolated, so that attacker connot change logic, 
			database.
			
			- RM should be able to be verified to prove the corectness. 
			
		
		* TCB: is everything in the trusted os to enforce the security policy. It is the portion of a 
		system that enforces a particular policy. The TCB is not usually a single part rather it is 
		spreaded out in the system in the hardware, kernel , ...
				 
	
	* Security policy VS Security model: 
		- Security policy is the goals that we expect the system to enforce. 
		- Security model is a representation of the security policy for the os. 
		
		- Formal security model is a mathematical description (formalisation) of the rules of the security 
		policy. It can be used for formal proofs of security. 
		
		
	* Development of a secure OS: can be made in six steps: 
	1) analyze of the system. 
	2) choose/define a security policy. 
	3) choose/create a security model based on the policy. 
	4) choose implementation method. 
	5) make a (conceptual) design. 
	6) verify the correctness of the design.
	
		
	* Decoy systems: is the system used to confuse and lure the attacker, the fake goal system for the 
	attacker.
	
	* Honeypot system: is a decoy system that lure the attacker. We can have a virtual machine to create a 
	honeypot system which will lure the attacker  and honeypot will be infected by the potential malware, then 
	we can use introspection to  amalyse the attack. 
	The hineypot system looks like a real system (as much as possible) but it is a completley fake. 
	This system can be mounted in the insternal or external network or in the DMZ
	
	The goals of honeypot system is: 
		- collecting information of attacker activity. 
		- diverting attackers from the real system. 
		- encourage the attacker to stay long enough on the system for the adminstrator to response. 
		
		* different types if honeypots: 
			+ production honeypots: easy to use. gathers limited information. used by companies, etc. 
			+ research honypots: complex to deploy and maintain. gathers extensive information.
			used by academia, military, goverments, etc. 
			
	
	FRS-system: (fragmentation, Replication, Scattering): is a system to protect files against attacks:
	a file being fragmanted to several fraagments then replicated and scattered to several repositoties then 
	each user has just fragments of a file and not whole the file. MORE INFO IN OFFPRINT
	
	
		
#...................................Malware (Malicious code)......................................

	* Malicious code: is any code added, changed or removed from a software in order to intentionally cause
	harm or subvet the intended function of the system. 
	Malicious code can be many things such as: viruses, worms, trojan horses, rabbits, etc. 
	From a technical viewpoint malicious code is a normal code. 
	
	Previously malware was normally of one specific kind but nowadays it's multifunctional and complicated. 
	Malware is targeting en-users through web-based attacks
	
	Nowadays Most viruses are non-destructive rather they try to  take control over computer for malicous
	porpuses such as becoming a zombie and distribute spam. 
	
	All kind of malware tend to be called virus such as Bagle, Mydoom, Netsky, Sasser, Kargo and sober, 
	Conficker. 
	
	 
	
	* Virus: 
		- Traditional virus: this typeof virus attaches to existing program code, intervenes in normal 
		execution, replicates and propagates. 
		
		- Document virus: higly formatted documents include commands (+data)
		
		- Stealth virus (and rootkits): hides the modifications it has made in the system , normally by 
		monitoring system calls and forging the results of such calls. 
		
		- Polymorphic virus: avoids virus scanners by producting multiple variant of itself or encrypting 
		itself.
		
		- Hoax virus: is not virus at all, it is a email with a bogus warning
		- Rabbit (or bacteria greedy programs): a visus or a worm that replicates without bound, thus 
		exhausting some computing resource. this type of virus deos not spread to other systems. 
		
		- worm: is a stand-alone program that replicates and spreads copies of itself via network. non-
		trivial to make
	
		- trojan horse: is a normal program that contains some hidden functionality that is unwanted by 
		the user.
		
		- Logic bomb: Malware that triggers on a condition and detonates. 
		
		- Time bomb: malware that triggers on a time condition and detonates.
		
		- Trap door (backdoor): is an undocumnted and unknown (to the user) entry point to the system. 
		Normally inserted durring the system design phase, and can be put there for a usfull purpose. 
		it can also be remained after system testing, maintenance nut left by mistake. 
		
		- Salami attack: Achiving some economic benefits but making a large number of insignitificant 
		changes e.g. rounding errors. 
		
		
		
		* different ways traditional virus infected system: 
			1) Virus Surrounding a program: 
			virus code runs , then original program runs, when original program ends virus runs again. 
		
			2) virus integrated into a program: 
			virus code is shared into diffrent places in the original code. 
		
			3) boot sector virus: the virus take the complete control of the system before the os was 
			loaded.
		
			normal booting before infection: 
			first boot sectore that includes bootstrap loader prepares for the system initialization
		
			infected booting: 
			virus takes place in the boot sector and moves the bootstrap loader into another sector. 
			så virus code runs first then bootstrap loader and then system initialization. 
		
		
		* Phases of viral action: 
		1) entry into system. 
		2) dormancy (dvala)
		3) propagation
		4) triggering
		5) action 
		
		
		* Driver-by download: download of malware through exploition of a web browser, email client or
		 operating system bug without any user intervention whatsoever.  
		
		
		
		* I love you/Loveletter malware: The point of origin is Malina, Philipines, the worm code was 
		written in visual basic script. there exist 82 diffrent types of Loveetter. 
			
			Duplication of loveletter virus: 
			1) primary way of duplication: by sending itself as an attached .txt file to all 
			recipients in MS outlook book. It created a flag in the register to make 
			sure that it will not be sent more than once to each recipient. each time os started up 
			it checked if a new repicient exists if yes the .txt file was sent to the new added 
			recipient as well. 
		
			2) Using IRC, sending phony .htm foles to users connecting to the same IRC channel as the 
			interface computer. if the victim was a web server this code tried to download pages link 
			to this infected files. 
			
			Why it happened: 
				- Win98 and win 2k contains the component "windows scripting host" which
				default allowed scripts. 
				
				-  Windows could be configured to hide file extention in the file browser so 
				file.txt could be shown as file. 
				
				- people in general trusted people they know
				
				- The script runs with user rights in the system. 
				
				
			* what does loveletter do: 
			 	1) create files in the file system: system directory: MSkernel32.vbs; 
			 	LoveLetter.txt.vbs
			 	
			 	2) Manipulates the windows registry: to garantee execution at wiindows start up. 
			 	3) tries to download the file WIN-BUGFIX.exe: a password stealing trojan horse. 
			 	4) reads the address book in MS outlook: in order to send itself to other 
			 	recipients. 
			 	
			 	5) Overwrite script files: rename the to .vbs
			 	6) Overwrites the IRC script files: to be able to send .htm copy of it self to 
			 	people connecting to same chat group as infected user. 
			 	
			 	NOTE: source code in slides!
			 	
			 	  
			

		* Morris worm: uses number of attack steps one of them is buffer over flow. 

			* Principle for function: 
			- intrusion (intrång)
			- Transfer of main program 
			- setting down and establishing (cracking accounts, hiding, etc)
			- Continued intrusoins

			* In this type of worm an infected system trie sto attack a target system by sending the worm to it
			after the system is infected there will be a grappling hook that is a small part code which requests the rest of attack codes 
			from the target that have been infected. the infected system then sends other part of codes for different attacks such as rsh attack, 
			finger attack, sendmail attac, ... these code being placed then in grappling hook in the target system. 

			* intrusion: 4 well known attacks:
			1) findning trust relations: 
			2) guess/crack passwords
			3) use debug facility in the sendmail mail handler
			4) exploit bug in finger program (buffer overflow)

			1) Finding trust relations: The host obtains host addresses to other systems to attack
			by examining the files: 
				+ the system tables: /etc/hosts.equiv
				+ /.rhosts
				+ user files like: .forward
				+ dynaic routing, information produced by the netstat
				+ randomly generated host addresses on local networks. 

			The goal of the findig trust relation attack is to find systems to login without password. 
			files named above contains names of machones that are likely permit unathenticated connections. 


			2) Guess/crack passwords:  the main goal for moris worm was to crack the password file to obtain all passwords. 

			3) Use debug facility in the senmail: by using trap door in the sendmail SMTP mail service. A bug 
			in debbuging code allows the daemon to execute a command interpreter and download code across a mail connection. 

			4) buffer overflow: explaned later. 


		* Mirai worm: one way it attacks is using default passwords, it had a list of 62 username and passwords. 
		This worm had also the ability to evolve(utveckla) itself i.e. it could delete binary, obfuscate proccess id,
		get updated with new passwords to it, closing of telnet port, killing of other variants, IP-based to domain based. 
		it coild be used also for DDoS attack, Botnet, ... 
		different Mirai worms are unique in many ways but still share much in common with the many threats that came before it. 



		* Morris vs Mirai worm: 
			+ Morris: A list of 432 build-in passwords
			+ Mirai: 62 usernames and passwords
			+ Both morris and mirai tried to hide itself by no binary left on the disk, and hiding process ID
			Mirai had succeeded better because it killed of completing strains but mooris failed to stop infecting a system because of a bug. 
		
		

		* Stuxnet: Advanced malware that targeted specifically PLC Siemenns SIMATIC step seven softwre. 
		it was one of the first wild malware's that targeting PLCs. 

		* Equation group: this group created some viruses. the virus could hi itself so that even cleaning disk the virus could hide itself and 
		re-infect the system. 



		* Rowhammer: it hammer in a value into the memory (attack in hardware)
			
			* Sandboxing: in modern web browser we use sondboxing to prevent malware from installing itself on the system 
			this will protects machine by adding an additional layer of protection to the browser so that e.g. javascript code that will be loaded in a webpage can't bring other code in itself i.e. malware. 
			With sandbox we will restrict the access of the page, the code, the process to just work with the limited part of the system 
			and not be able to reach outside of this boundary that we created. 

			* Computer memory: DRAM
			Dynamic random access memory is type of memory that is typically used for data or program code. It 
			stores each bit of data or program code in a storage cell. The storage cell consists of a capacitor and a transmitor
			and it is typically organized in a rectangular configuration of storage cell. 

			DRAM storage cell is dynamic, it needs to be refreshed or given a new electronic charge every few milliseconds (64 ms)
			to compensate for harge leaks from the capacitor. 

			Since DRAM cells getting smaller and smaller then interaction between them increases. So accessing one location
			in the memory can distrub neighbouring location which can cause charge to leak into or out of neighbouring cells. 
			With enough accesses, this can change a cell's value from 1 to 0 or vice versa. 


			* Attack in form of rowhammer:  
				- write enough time to a row will distrub a neighbouring row. 
				since the system needs a refresh rate the wnuogh write time must be between system refresh write (<64 ms)
				The DRAM bank has a current activated row so attacker have to say the way to write
				- attacker should write to different rows within same bank basically rowhammering. The
				best is write adjacent to the one attacker want to change
				- avoid cache
			This attack effect pysical memory for example change addresses in memory and changing the page table to 
			modify SUID-root executable such as /bin/ping, overwriting its entry point with attack shell code and run it
			then shell code will run as root. 

			This attack can also be used and be puted into java script to break down sandbox. 

		* Spectre (version 1): 
		this types of attack called meltdown and Spectre were no ordinary bug. At the time it was discovered, 
		Meltdown could hack all intel x86 microprocessors and IBM power processors and some ARM-based processors. 
		Spectre could hack even AMD (Advanced micro devies) as well. 

		Versions of this attack: 
		v1) Bound check by pass: ability to read outside of the bound of an array
		v2) branch target injection
		v3 Meltdown) rouge data cache load

		this type of attack can take place in different places in system such as: 
		- operating system
		- side channel, e.g. cache contains the recently used data
		- Return-Oriented programming: redirecting the control flow e.g. buffer overflow
		- Speculative execution: cpu is fast since memory is slow 

		speculative example: 
		if (x< array1_size):
			y = array2[array1[x]*256];
		then get the value and index array2. 


		* Typical order of magnitude: 
		execute typical instruction--------------> 1/1,000,000,000 sec = 1 nanosec
		fetch from L1 cache memory---------------> 0,5 nanosec
		branch mispredication--------------------> 5 nanosec
		fetch from L2 cache memory---------------> 7 nanosec
		mutex lock/unlock------------------------> 25 nanosec
		fetch from main memory-------------------> 100 nanosec
		send 2kb over 1Gbps network--------------> 20,000 nanosec
		read 1MB sequencially from memory--------> 250,000 nanosec
		fetch from new disk location (seek)------> 8,000,000 nanosec
		read 1MB sequentially from disk----------> 20,000,000 nanosec
		

#...................................Bufferoverflow..................................................................
	
	-------------------------------------------   0Xbfffffff
	|	Stack: contains env/ARG string/   |
	|		pointer			  |
	|-----------------------------------------|
	|	heap: dynamic memory, malloc	  |
	|-----------------------------------------|
	|	.bss: variables not initialized	  |
	|-----------------------------------------|
	|	.data:	initialized variables	  |
	|-----------------------------------------|
	|	.text: contains the code and  	  |
	|	instructions			  |
	-------------------------------------------

	* Bufferoverflow: when puting data into a variable/buffer that has size larger than the buffer. 
	this can lead for examlṕle overwritting the memory so that the data in memory going lost.  
	For examole attacker using bufferoverflow overwrrite the return address for a program and jump to the stack address to execute his code. 

	Expolit: 
	- Attacker can change/overwrite the return addressin the stack så that program does not returns and attacker can play around with te stack 
	- Attacker can also inject his code using buffer overflow and run its code. 
	- Attacker can take control of the envaitonment i.e overwrite other locations. 

		* the attacker needs a program in the buffer or environment, which is easy.
		this code calls offten shellcode beacause the idea is that open a shell and run commands. 
		typical injection vector looks like below:	
			|NOP sled|shellcode|address of shellcode|

			- shellcode address: the address of the meomory region that contains the shellcode. 
			- shellcode: a sequence of machine instructions to be executed e.g. execve("/bin/sh") to run a shell command
			- NOP sled which is optional: a sequence of do-nothing instructions (nop). It is used to ease the expliotion, attacker 
			can jump anywhere inside, and will eventually reach the shellcode. 
			NOTE: for prepending the NOP sled in 0x86:
			perl -e 'print "\x90"' | ndisasm -b 32 - 00000000 90 nop

			* algorithm to how do a attack using bud´ffer overflow:
			- create the shellcode
			- prepend the NOP sled
			- add the address of the shellcode 

			* in reality thing are more complicated: the attacker needs to use encoding and unpacking
			The shellcode should be encoded andshell code should be unpacker to be runned. 
			for example strcpy() (and most other other functions) will stop when it encounters the null buye. so if the shellcode contains a null byte
			the attacker has a problem. Therefor the attacker have to encode the shellcode to remove the null bytes
			and then generate them dynammically. 


	
	* Countermeasures:three different system defenses
	- NX bit
	- Canaries
	- ASLR
	
		* Canaries: Compiler-level techniques
		To protect the stack. The goal in this mechanism is to make sure that we detect overflow of return address before we use the return address  
			+ the functions' prologues insert a canary on the stack. 
			+ the canary is a 32-bit value inserted between the return address and local variable. 
		There is three types of canaries: 	
			1) terminator
			2) random
			3) random xor
		The epilogue checks if the canary has been alerted i.e it checks that the canary has not been alerted before using the return adddress
		Drawback of this mechanism is that it requires recompliation. 

		Basically we use cannaries to protect the stack. the canary will be placed between the local variables and frame pointer
		so if there is a buffer overflow it will go through the canary and we will detect it. 
		When attacker does buffer overflow the value of canary being changed, the attacker still can overwrite everything up to the return address 
		but the buffer overflow will be detected. In this way we can stop the program when buffer overflow detected
		so that the attacker beint not able to run his code. 

		NOTE: even this mechanosm isnot safe tha attacker can pass the canary and run his own code. by jumping over the canary. 
		so canary value will be unchanged and the buffer overflow will not be detected. 


		* NX bit/DEP (Data Execution Prevention)/W xor X: system-level defense
		To pevent execution of the stack. The idea is to separate executable memory locations from writable ones. So a memory page will not be able to be both 
		writable and executable at the same time. 

		How to violate this mechanism? return into libc
		for this porpuse (break this mechanism): 
			- we can manipulate a code pointer
			- the stack is writable
			- we know the address of a suitable library function such as system()
		using these functions the attacker can overwritte the return address of the the vulnerable functio. 


			#Return-oriented programming (ROP chain) attack: 
			- small snippets of code ending with a return 
			- can be chained together. 
			by using this small pieces of code that have return in a chain in right order we can execute our own code. 
			this method can be used to break the canary mechanism 


		* ASLR (address space layout randomisation): system-level defense
		To randomize the stack and the start address of the code. The idea is to randomly arrange the base addresses of the libraries, heap and stack, etc:
			+ re-arrange the position of key data areas, randomly (stack, .data, .text, shared labraries, ...)
			+ The attacker would not know the address of the shellcode. 
			+ return into libc: the attacker can not predict the address of the library functions
		this mechanism is implemented in linux kernel > 2.6.11, Windows , ... 

			ASLR problems: 
			- 32-bit implementations use few randomization bits. This is even worse for the Iot and embedded systems since they are smaller. 
			- An attacker can still expliot non-randomised areas, or rely on other informations leaks. e.g. format bug.
			- It will be problematic if all functions are still at the same relative offset from start address of the code. 
			Then the attacker needs only a single code pointer. 



#....................................DOS (Denial of service attacks).......................................................

	DoS (Denial of service): An action that prevents or impairs the authorixed use of the networks, system, or applications by exhausting 
	or terminating resourses sush as CPU, memory, bandwidth and disk space. two types of DoS attack:
		- overload/flood attcks: 
			+ network bandwidth.
			+ system resources. 
			+ application resources

		- crash and kill: 
			+ DoScan also be accoplished by killing the server. 
			+ Find vulnerabillity in code ... 

	* What in CIA can be targeted in DoS attack? 


		* Overload/flooding: this type of attack needs a powerfull system
			- from higher capacity network link to lower. 
			- causing loss f traffic
			- can use simple flooding ping (ping flood)
				+ ICMP flood: uses ICMP packets, e.g echo request. typpically allowed
				trough, some required.

				+ UDP flood: uses UDP packets to some port.
			
				+ TCP sync flood: uses TCP SUNC (connection request) packets to overload the network.


				+ SYN spoofing: To target the victims memory: This attack can be use as SYN spoofing as well where the clinet (attacker) 
				sends lot of sync packet and the server has to keep track of half open connections.
				In this way the server will store half open connections in memory.

				The problem for the attacker in TCP Syn is that server sends also response packet so the attckers network band 
				will also be overloaded. the other problem is that the attcaker will be identified.
				this attack may be easily blocked. THe attacker needs spoof IP. 

				# Attacker can use a spoofed client so attcker can spoof its ip. 
				The attacker should use a spoofed client that not exists in this way the 
				half open connection will not be removed on the server. 

					In syn spoofing the attacker: 
						uses: either random source addresses, or an overloaded server
						to block return of the reset packets. 

						has lower traffic volume. 



			*problem for the attacker:  source of flood traffic easily identified. 
				+ alternatives: SYNC spoofing targeting system resource/code/memory...
			so the victim can find the attacker by e.g ip-address and do legal actions. 
			this type of attack is also easy to block. and responsing back to origin is slow. 

		* Crash/kill: with this attck there is no need of a powerful system
			- Trigger bug in system (poison packet)
			- calssical examples:
				+ land attack: the attacker will create a packet with the source address same as the destination address. 
				And source port same as the destination port. 

				+ ping-of-death: this is basically a echo request, in this case tha attacker sends an oversized packet to the victim. 



	* Distributed DoS (DDoS): where many system controled by the attcker to attack the victim. 
	- conists of multiple systems. this will aloow higher traffic volumes to form a distributed
	DoS attack. 

	- often comprimised PC's/workatations. These PC's has been infected by zoombies with backdoorprograms, and forms a "botnet"
	-EX: Trible Flood Network (TFN), TFN2K

	This type of atack is more difficult to block since there are many systems that overload the system.

	DDoS control hierarchy: the attacker speaks with handlers. handler zoombies are also infected 	
		hosts that can control other hosts (agent zoombies). In this way the target only sees the agent zoombies.


	Reflection and Amplification attacks: this concept includes that the attcaker gain their objective. 

		- Reflection attack: the attacker will use normal behavior of the network. The attacker
		tries to send packets with spoofed source address being that of target to a server ( motsvarande target till en server), i.e
		the attacker sends packet with spoofed source as a device in the network so the device will be a victim.
		The server will response and the response is directed at target (victim server or system). 
		In this case if the attacker sends many requests to multiple servers, response can flood the target. 
		The attacker can use various protocols e.g. UDP or TCP/SYN

	 	- Amplification attack: In this type of attack the attacker will have number of zombies. 
		The zombies will find some reflector intermidiaries that will then contect the target. 
		The goal of this type of attack is that the attacker will scale up the factor.
		
		- Smurf attack: the classic one
		in this attack the attacker will flood the network with excessive packets. 
		the attacker will send ping to broadcast address of the network. 
		The attacker will spoof the return to be the victim's address. In this way every one in the network will
		respond the ping to the victim. 

		- Fraggle attack: which sends large UDP to the broadcast address of the network. this will 
		have same effect as Smurf attack. 
	


	* Defenses against DoS: 
		1) attack prevention and preemption. 
		2) attack detection and filtering.
		3) attack source traceback and identification. 
		4) attack reaction (after attack) to curtail effects of an attack. 

	NOTE: High traffic volumes happens becasue of other reasons such as:
	+ Legitimate result of high publicity 
	+ A very popular site 

		* Attack Prevention: 
		- By blocking: block spoofed source addresses on routers as close to source as possible. still far too rarely implemented. 
		- Rate: rate controls in upstream distribution nets. It can be done on specific packets e.g. some ICMP, some UDP, TCP/SYNC
		- Modified TCP: use nodified TCP connection handling. Use SYN cookies when table full. 
		or selective or random drop when table full. 

	
		* Responding to attack: for this porpuse we have to:
		- Identify type of the attack: capture and analze packets. Design filters to block attack traffic upstrea,. 
		or identify and correct system/application bug. 

		- ISP traceback: have ISP trace packet flow back tosource. It may be difficult and time consuming. 
		It can be necessary if legal action desired. 

		- Contingency plan: implement contigency plan 
		- Update incident response plan. 



	* MIRAI botnet: First attacker need to do internet-wide scanning to find devices. After that MIRAI will 
	try ti find insecure default passwords then if it was successful it was reported to the server
	and later returned to it with a simple payload to infect hetrogeneous devices. 
		
		MIRAI cycle: 
		1) Find victim which can be done by scanning e.g. Asynch, stateless, TCP SYN to 23 2323
		And bruteforce login (62 credential, try 10 times). If it was successful report to the server. 

		2) The victim device is infected by a loader program. The job of this program is to check what is the system environment. 
		And download the system spec malware. 

		3) The MIRIA tries to conceal and obfuscate itself, so it did not persist over reboots. 

		4) it killed itself off if other version of it was infected the system. 

		Types of MIRAI attack: 
		- DDoS attack. 
		- volumetric 
		- TCP state exhaustion.
		- application layer attacks.
		- bandwidth amplification (built in)


#....................................Defensive programming.............................................

	
	Never trust user input!

	Defensive programming/Secure programming:
	- Must always validate assumptions, nothing is assumed
	- needs an awareness of consequenses of failures (understanding what can happen and what it can lead to)
	- understanding the thechnologies used by attackers 

	* Diffrent organisation have toke track of similar vulnerablites exploited over time (CERT)
		- injection attacks (ex12.2)

	
	* Domians: 
	1) Handling program input: buffer overflows, Injections attacks. 
	2) writing safe program code
	3) interacting with OS and other programs
	4) handling program output 
	
	* Types of injection attck: 
	- Code injection
	- Control flow
	- Dat ainjection
	- Command Injection 
	- ...


	* History of Command injection: long time ago CGI had been used and programing in perl to fork a shell in web 

		The user sends request about a resource to the server and server sent the resource to the user.  
		In beginging of the web, servers used shell to prepare the resources requested by users, this was done though
		CGI (command gateway interface). The web server could trogh the CGI fork a shell and run some code in the shell, it happend with same proviliges as web server. 
		The communication was implemented by Perl. 
		An attacker could attack the system by using characters meaning, characters have different meanings. 
		Attacker could for example use code as input data or rather commands as input data. 

		* Command injection mitigation technique by two methods:
		1) Define what is known dangerous input. (this way is the difficult one, may miss some cases) 
		2) define what is valid input. (it's easier to define valid inputs!)

	* problems: 
	- Definition of what is really dangerous is difficult
	- different (multiple) encodings: e.g for web, space can be %20,/=%2, ;=%3B
	- not only strings can be injected, also other types of data such as integer overflow. 

	* the best way is to define valid inputs!

	* Open Web Application Security Project (OWASP) is an organization focused on improving the security of application software. 
	Some attcs listed byOWASP:
		1) Injection: Injectio flaws, such as SQL, NOSQL, OS, and LDAP injection, occur when untrusted data is sent to an interpreter as part
		of a command or query. The attacker's hostile data can trick the interpreter to executing unintended commands or accessing 
		data without proper authorization. 
			- SQL injection: Access or modify data in DB.
			- SSL injection: Execute commands on server and access sentensive data. 
			- LDAP Injection: Bypass authentiation
			- ...


		2) Cross-site Scripting: XSS flaws occur whenever an application takes untrusted data and sends it to a web browser without proper validation
		or escaping. XSS allows attackers to execute scripts in the victim's browser which can hijack user sessions,
		deface web sites, or redirect the user to malicoius sites. 




#......................................Network Security.....................................................

	The CIA concepts are in fokus in network security as well:

	* Authentication: The attacker will spoof packets, there is a security mechanism called kerberos, whish works in authentication domain.
	* Availability: attacker can attack against availibility e.g. denial of service attack. 

	* Reasons that lead to insecure network: 
		insecure medium: 
		- insecure medium: almost impossible to secure the network itself, i.e. the communication links. 
		- Always assume attackers can bug and modify all traffic.

		Unknown communication path: 
		- Several routers between two nodes. 
		- Lack of control of the network. 

		Unknown perimeter boundary:
		- Several points of attacks, we can reduce them by firewall

		Anonymity:
		attacker can hide himself using e.g. TOR, ... 

	Some networking attcks: 
	- port scanning: is a general information-gathering activity. It is a way to find open ports in hosts that can be used for attackers.
	there ay be diffrent vairaints such as Stealth scanning. This technique use in mirai to find open ports to infect and keep the communication. 

	- spoofing: It means pretending to be the real owner of an address which is incorrect. It may also mean falsely providing
	a service instead of the real service provider. There are several types of spoofing:
		+ ARP (address Resolution Protocol) spoofing: ARP is used in LANs to map the host's ip address to the MAC address. 
		The ARP spoofing or poisoning means sending faked ARP replies to a LAN. The ARP request packet is broadcast to
		the network segment. Any one can answer. Giving a wrong answer can confuse the network devices, e.g. routers. 
		This may result in that the communication will be directed to ann incorrect host. 
		It may also result in that the correct host is unreachable, a DOS attack. 
	
		+ IP address spoofing: exploits the trust relationship between two hosts, the trusted host and the victim host: 
		Attacker can send a packet to the victim host with a false source address(i.e. that of the trusted host).
		The victim's replies will still go to the trusted host. Thus the attacker does not see them. 
		In some way (DOS attack) attacker can disable the trusted host. The attacker then need also to find out the sequence numbers somehow, 
		otherwise the spoofed packets will not be accepted by the victim. 
	
		+ DNS spoofing: means directing users to a false server. This can be accomplished in several ways:
			- By making a fake maping betwen hostname and IP address at the vitim's web client. 
			- By IP spoofing, so that the IP address request goes to a false DNS server. 
			- Attacking the real DNS server and changing entries in its cache memory. 
		
		+ Web spoofing: fools the victim to think that he is cisiting a legitimate site, whereas he is really visiting the 
		attackers's site. The attacker can do it by: 
			- By providing a false link by compromising a comon web page. 
			- by providing a false web address, that may be confused with the real one. e.g bank.com instead of bank.se
		This may couse all communication to pass throug the attackers's server. 

	- Man in the middle attack: is an attack in which the attacker (logically) places himself between the two hosts that are
	communicating. Both parts think that they are communicating with one another but in fact both of them are communicating
	with the attacker's server. This attack can be accomplished by many ways such as: 
		+ Using web spoofing. 
		+ By ARP poisoning using tools like Hunt.
		+ By ICMP redirection of packets. 
		+ By DNS poisoning
	The attacker can also passively monitor the communication between the parties, e.g. to collect sentensive information (a passive attack!)


	starta video nr2: firewalls



























		
	








